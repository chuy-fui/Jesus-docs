{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"INICIO/","title":"INICIO","text":""},{"location":"INICIO/#este-es-una-pagina-en-donde-se-encuentran-mis-proyectos-de-la-universidad","title":"Este es una pagina en donde se encuentran mis proyectos de la universidad","text":""},{"location":"Games/gamedisney/","title":"Gamedisney","text":"Submit Next"},{"location":"SE/Examen2/","title":"Examen 2","text":""},{"location":"SE/Examen2/#1-control-de-servomotores-con-comandos","title":"1) Control de Servomotores con comandos","text":""},{"location":"SE/Examen2/#hardware-minimo","title":"Hardware m\u00ednimo","text":"<p>1 \u00d7 servomotor en un pin PWM (50 Hz).</p> <p>3 \u00d7 botones:</p> <ul> <li>BTN_MODE: cambia el modo activo (c\u00edclico: Entrenamiento \u2192 Continuo \u2192 Step \u2192 \u2026).</li> <li>BTN_NEXT: avanza a la siguiente posici\u00f3n (s\u00f3lo en Step).</li> <li>BTN_PREV: retrocede a la posici\u00f3n anterior (s\u00f3lo en Step).</li> </ul> <p>Pi Pico 2</p>"},{"location":"SE/Examen2/#modos-de-operacion","title":"Modos de operaci\u00f3n","text":""},{"location":"SE/Examen2/#1-modo-entrenamiento","title":"1) Modo Entrenamiento","text":"<p>Se recibe texto por USB-serial con los comandos siguientes (se aceptan min\u00fasculas/may\u00fasculas indistintamente y tambi\u00e9n sus alias en ingl\u00e9s):</p>"},{"location":"SE/Examen2/#borrar-alias-clear-borrar","title":"Borrar (alias: clear, borrar)","text":"<p>Sintaxis: Borrar</p> <p>Efecto: elimina la lista completa de posiciones.</p> <p>Respuesta: OK</p>"},{"location":"SE/Examen2/#escribir-alias-write-escribir","title":"Escribir (alias: write, escribir)","text":"<p>Sintaxis: Escribir, v1, v2, ..., vn</p> <p>vi son enteros en 0\u2013180.</p> <p>Efecto: sobrescribe la lista con los valores dados en ese orden.</p> <p>Respuesta: OK si todos son v\u00e1lidos y la lista de posiciones; si alguno est\u00e1 fuera de rango o la lista queda vac\u00eda \u2192 Error argumento invalido</p>"},{"location":"SE/Examen2/#reemplazar-alias-replace-reemplazar","title":"Reemplazar (alias: replace, reemplazar)","text":"<p>Sintaxis: Reemplazar, i, v</p> <p>\u00cdndice i en base 1 (1 = primera posici\u00f3n).</p> <p>v en 0\u2013180.</p> <p>Efecto: reemplaza el elemento i por v.</p> <p>Respuesta: OK. Si i no existe \u2192 Error indice invalido. Si v fuera de rango \u2192 Error argumento invalido.</p>"},{"location":"SE/Examen2/#2-modo-continuo","title":"2) Modo Continuo","text":"<p>Recorre todas las posiciones de la lista en orden, moviendo el servo e imprimiendo cada 1.5 s:</p> <p>Formato: posX: V (por ejemplo, pos1: 90), donde X es base 1.</p> <p>Si la lista est\u00e1 vac\u00eda: imprimir cada 1.5 s Error no hay pos y no mover el servo.</p> <p>Al cambiar a otro modo, el ciclo se detiene inmediatamente.</p>"},{"location":"SE/Examen2/#3-modo-step","title":"3) Modo Step","text":"<p>BTN_NEXT: avanza una posici\u00f3n (si ya est\u00e1 en la \u00faltima, se mantiene en esa \u00faltima).</p> <p>BTN_PREV: retrocede una posici\u00f3n (si ya est\u00e1 en la primera, se mantiene en la primera).</p> <p>En cada cambio de posici\u00f3n:</p> <ul> <li>mover el servo a la posici\u00f3n seleccionada;  </li> <li>imprimir posX: V.</li> </ul> <p>Si la lista est\u00e1 vac\u00eda: al presionar BTN_NEXT o BTN_PREV, imprimir Error no hay pos y no mover el servo.</p>"},{"location":"SE/Examen2/#info-importante","title":"INFO IMPORTANTE","text":"<p>El movimiento de un servo requiere:</p> <ul> <li>Alimentaci\u00f3n: 5\u20136 V  </li> <li>Se\u00f1al de control: PWM a 50 Hz  </li> <li>Pulso: 1\u20132 ms (representa 0\u2013180 grados)</li> </ul> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n#define SERVO_PIN 0\n#define SERVO_MIN 1000\n#define SERVO_MAX 2000\n#define FREC 50\n\n#define B_MODE 1\n#define B_NEXT 3\n#define B_PREV 2\n\n#define MAX_POS 10\n\nstring mensaje = \"\";\nint posiciones[MAX_POS];\nint total_pos = 0;\nint modo = 0;\nint pos_actual = 0;\nuint32_t ultimo_continuo = 0;\n\n// Funci\u00f3n para mover el servo\nvoid mover_servo(int angulo) {\n    if (angulo &lt; 0) angulo = 0;\n    if (angulo &gt; 180) angulo = 180;\n\n    float pulso = SERVO_MIN + (angulo / 180.0f) * (SERVO_MAX - SERVO_MIN);\n    float periodo = 1000000.0f / FREC;\n    uint16_t duty = (uint16_t)((pulso / periodo) * 65535);\n    pwm_set_gpio_level(SERVO_PIN, duty);\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configurar PWM\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);\n    pwm_set_wrap(slice, 65535);\n    pwm_set_clkdiv(slice, 125000000.0f / (FREC * 65536));\n    pwm_set_enabled(slice, true);\n\n    gpio_init(B_MODE);\n    gpio_set_dir(B_MODE, GPIO_IN);\n    gpio_pull_up(B_MODE);\n\n    gpio_init(B_NEXT);\n    gpio_set_dir(B_NEXT, GPIO_IN);\n    gpio_pull_up(B_NEXT);\n\n    gpio_init(B_PREV);\n    gpio_set_dir(B_PREV, GPIO_IN);\n    gpio_pull_up(B_PREV);\n\n    while (true) {\n        // Cambio de modo\n        if (!gpio_get(B_MODE)) {\n            modo = (modo + 1) % 3;\n            pos_actual = 0;\n            if (modo == 0) printf(\"Modo Entrenamiento\\n\");\n            else if (modo == 1) printf(\"Modo Continuo\\n\");\n            else printf(\"Modo Step\\n\");\n            sleep_ms(300);\n        }\n\n        // Modo Entrenamiento\n        if (modo == 0) {\n            int ch = getchar_timeout_us(10000);\n            if (ch != PICO_ERROR_TIMEOUT) {\n                char c = (char)ch;\n                if (c == '\\r' || c == '\\n') continue;\n                mensaje += c;\n\n                if (c == ';') {\n                    string comando = mensaje.substr(0, mensaje.length() - 1);\n                    string cmd_lower = comando;\n                    for (auto &amp;ch : cmd_lower) ch = tolower(ch);\n\n                    // Comando clear/borrar\n                    if (cmd_lower == \"clear\" || cmd_lower == \"borrar\") {\n                        total_pos = 0;\n                        printf(\"OK\\n\");\n                    }\n                    // Comando write/escribir\n                    else if (cmd_lower.substr(0,5) == \"write\" || cmd_lower.substr(0,7) == \"escribir\") {\n                        int inicio = comando.find(',') + 1;\n                        bool error = false;\n                        while (inicio &gt; 0 &amp;&amp; inicio &lt; comando.length() &amp;&amp; total_pos &lt; MAX_POS) {\n                            int fin = comando.find(',', inicio);\n                            if (fin == string::npos) fin = comando.length();\n                            string val_str = comando.substr(inicio, fin - inicio);\n                            int val = atoi(val_str.c_str());\n                            if (val_str.empty() || val &lt; 0 || val &gt; 180) { error = true; break; }\n                            posiciones[total_pos++] = val;\n                            inicio = fin + 1;\n                        }\n                        if (error || total_pos == 0) printf(\"Error argumento invalido\\n\");\n                        else {\n                            printf(\"OK. Posiciones: \");\n                            for (int i = 0; i &lt; total_pos; i++) printf(\"%d \", posiciones[i]);\n                            printf(\"\\n\");\n                        }\n                    }\n                    // Comando replace/reemplazar\n                    else if (cmd_lower.substr(0,7) == \"replace\" || cmd_lower.substr(0,9) == \"reemplazar\") {\n                        int pos1 = comando.find(',') + 1;\n                        int pos2 = comando.find(',', pos1);\n                        if (pos1 &gt; 0 &amp;&amp; pos2 != string::npos) {\n                            int idx = atoi(comando.substr(pos1, pos2 - pos1).c_str()) - 1;\n                            int val = atoi(comando.substr(pos2 + 1).c_str());\n                            if (idx &lt; 0 || idx &gt;= total_pos) printf(\"Error indice invalido\\n\");\n                            else if (val &lt; 0 || val &gt; 180) printf(\"Error argumento invalido\\n\");\n                            else {\n                                posiciones[idx] = val;\n                                printf(\"OK\\n\");\n                            }\n                        } else printf(\"Error argumento invalido\\n\");\n                    }\n                    else printf(\"C\u00f3digo no reconocido\\n\");\n\n                    mensaje = \"\";\n                }\n            }\n        }\n\n        // Modo Continuo\n        if (modo == 1) {\n            uint32_t now = to_ms_since_boot(get_absolute_time());\n            if (now - ultimo_continuo &gt;= 1500) {\n                if (total_pos == 0) printf(\"Error no hay pos\\n\");\n                else {\n                    mover_servo(posiciones[pos_actual]);\n                    printf(\"pos%d: %d\\n\", pos_actual + 1, posiciones[pos_actual]);\n                    pos_actual = (pos_actual + 1) % total_pos;\n                }\n                ultimo_continuo = now;\n            }\n        }\n\n        // Modo Step\n        if (modo == 2) {\n            if (!gpio_get(B_NEXT)) {\n                if (total_pos == 0) printf(\"Error no hay pos\\n\");\n                else if (pos_actual &lt; total_pos - 1) pos_actual++;\n                if (total_pos &gt; 0) {\n                    mover_servo(posiciones[pos_actual]);\n                    printf(\"pos%d: %d\\n\", pos_actual + 1, posiciones[pos_actual]);\n                }\n                sleep_ms(200);\n            }\n            if (!gpio_get(B_PREV)) {\n                if (total_pos == 0) printf(\"Error no hay pos\\n\");\n                else if (pos_actual &gt; 0) pos_actual--;\n                if (total_pos &gt; 0) {\n                    mover_servo(posiciones[pos_actual]);\n                    printf(\"pos%d: %d\\n\", pos_actual + 1, posiciones[pos_actual]);\n                }\n                sleep_ms(200);\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SE/Examen2/#video","title":"Video","text":""},{"location":"SE/PoyectoF/","title":"\ud83d\udc2d Capstone Micromouse","text":""},{"location":"SE/PoyectoF/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>El proyecto Micromouse consiste en dise\u00f1ar y programar un robot m\u00f3vil aut\u00f3nomo capaz de explorar un laberinto, construir un mapa y ejecutar una carrera r\u00e1pida (fast run) desde el inicio hasta el objetivo en el centro.</p>"},{"location":"SE/PoyectoF/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/i2c.h\"\n#include \"tof.h\" \n\n#define XSHUT_L 22\n#define XSHUT_F 3\n#define XSHUT_R 7\n#define ADDR_L 0x30\n#define ADDR_F 0x31\n#define ADDR_R 0x32\n\n#define PWMA 10  \n#define AIN2 11\n#define AIN1 12\n#define BIN1 13\n#define BIN2 14\n#define PWMB 15  \n#define ENC_IZQ_C1 21 \n#define ENC_DER_C1 5\n#define LED_PIN 25 \n\n#define TICKS_GIRO  175     \n#define TICKS_CELDA 465     \n#define SETPOINT_L  86     \n#define SETPOINT_R  61      \n\n#define VEL_EXPLORACION 11500 \n#define VEL_SPEED_RUN   16000 \n#define VEL_GIRO        14000\n#define VEL_LENTO       9000  \n\n#define KP_PARED    25      \n#define KD_PARED    350     \n#define KP_ENC      30     \n#define CLAMP_PID   6000    \n\n#define UMBRAL_PARED_LAT 180 \n#define DIST_STOP        50  \n\n#define ANCHO 12\n#define ALTO  12\n\n#define NORTE 0\n#define ESTE  1\n#define SUR   2\n#define OESTE 3\n\n#define PARED_N 1\n#define PARED_E 2\n#define PARED_S 4\n#define PARED_W 8\n\ntypedef struct {\n    uint8_t paredes;    \n    uint8_t distancia;  \n    bool visitada;      \n} Celda;\n\nCelda mapa[ANCHO][ALTO];\nint robot_x = 0;        \nint robot_y = 0;\nint orientacion = NORTE; \n\ntypedef struct { int x; int y; } Punto;\nPunto cola[ANCHO * ALTO]; \n\nvolatile long ticks_izq = 0;\nvolatile long ticks_der = 0;\n\nvoid encoder_callback(uint gpio, uint32_t events) {\n    if (gpio == ENC_IZQ_C1) ticks_izq++;\n    else if (gpio == ENC_DER_C1) ticks_der++;\n}\n\nvoid init_sensor_individual(uint pin, uint8_t addr) {\n    gpio_put(pin, 1); sleep_ms(15);\n    tofInit(1, 0x29, 0); vl53l0x_setAddress(addr); sleep_ms(10);\n}\n\nvoid set_motors(int L, int R) {\n    if(L&gt;65535) L=65535; if(L&lt;0) L=0;\n    if(R&gt;65535) R=65535; if(R&lt;0) R=0;\n    gpio_put(AIN1, 1); gpio_put(AIN2, 0); pwm_set_gpio_level(PWMA, L);\n    gpio_put(BIN1, 1); gpio_put(BIN2, 0); pwm_set_gpio_level(PWMB, R);\n}\n\nvoid frenar_total() {\n    gpio_put(AIN1, 1); gpio_put(AIN2, 1);\n    gpio_put(BIN1, 1); gpio_put(BIN2, 1);\n    pwm_set_gpio_level(PWMA, 65535); pwm_set_gpio_level(PWMB, 65535);\n    sleep_ms(200); set_motors(0, 0); sleep_ms(50);\n}\n\nvoid mover_motores_dir(int velocidad, bool hacia_adelante) {\n    if (hacia_adelante) {\n        gpio_put(AIN1, 1); gpio_put(AIN2, 0);\n        gpio_put(BIN1, 1); gpio_put(BIN2, 0);\n    } else {\n        gpio_put(AIN1, 0); gpio_put(AIN2, 1);\n        gpio_put(BIN1, 0); gpio_put(BIN2, 1);\n    }\n    pwm_set_gpio_level(PWMA, velocidad);\n    pwm_set_gpio_level(PWMB, velocidad);\n}\n\nint leer(uint8_t addr) {\n    i2cAddress = addr; return tofReadDistance();\n}\n\nvoid setup_system() {\n    stdio_init_all();\n    gpio_init(LED_PIN); gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    gpio_init(AIN1); gpio_set_dir(AIN1, GPIO_OUT); gpio_init(AIN2); gpio_set_dir(AIN2, GPIO_OUT);\n    gpio_init(BIN1); gpio_set_dir(BIN1, GPIO_OUT); gpio_init(BIN2); gpio_set_dir(BIN2, GPIO_OUT);\n    gpio_set_function(PWMA, GPIO_FUNC_PWM); gpio_set_function(PWMB, GPIO_FUNC_PWM);\n    pwm_set_wrap(pwm_gpio_to_slice_num(PWMA), 65535); pwm_set_wrap(pwm_gpio_to_slice_num(PWMB), 65535);\n    pwm_set_enabled(pwm_gpio_to_slice_num(PWMA), true); pwm_set_enabled(pwm_gpio_to_slice_num(PWMB), true);\n\n    gpio_init(ENC_IZQ_C1); gpio_set_dir(ENC_IZQ_C1, GPIO_IN);\n    gpio_init(ENC_DER_C1); gpio_set_dir(ENC_DER_C1, GPIO_IN);\n    gpio_set_irq_enabled_with_callback(ENC_IZQ_C1, GPIO_IRQ_EDGE_RISE, true, &amp;encoder_callback);\n    gpio_set_irq_enabled(ENC_DER_C1, GPIO_IRQ_EDGE_RISE, true);\n\n    i2c_init(i2c1, 400000);\n    gpio_set_function(26, GPIO_FUNC_I2C); gpio_set_function(27, GPIO_FUNC_I2C);\n    gpio_pull_up(26); gpio_pull_up(27);\n\n    gpio_init(XSHUT_L); gpio_set_dir(XSHUT_L, GPIO_OUT); gpio_put(XSHUT_L, 0);\n    gpio_init(XSHUT_F); gpio_set_dir(XSHUT_F, GPIO_OUT); gpio_put(XSHUT_F, 0);\n    gpio_init(XSHUT_R); gpio_set_dir(XSHUT_R, GPIO_OUT); gpio_put(XSHUT_R, 0);\n    sleep_ms(100);\n\n    init_sensor_individual(XSHUT_L, ADDR_L);\n    init_sensor_individual(XSHUT_F, ADDR_F);\n    init_sensor_individual(XSHUT_R, ADDR_R);\n}\n\n\nvoid centrar_frente_a_pared() {\n    int d_F = leer(ADDR_F);\n\n    if (d_F &gt; 0 &amp;&amp; d_F &lt; 150) {\n\n        unsigned long t_inicio = to_ms_since_boot(get_absolute_time());\n\n        while (abs(d_F - DIST_STOP) &gt; 2) {\n\n            if (to_ms_since_boot(get_absolute_time()) - t_inicio &gt; 1000) break;\n\n            d_F = leer(ADDR_F);\n            if (d_F &lt;= 0 || d_F &gt; 160) break; \n\n            if (d_F &lt; DIST_STOP) mover_motores_dir(VEL_LENTO, false); \n            else mover_motores_dir(VEL_LENTO, true);  \n\n            sleep_ms(10);\n        }\n        frenar_total();\n\n        ticks_izq = 0; ticks_der = 0; \n    }\n}\n\nvoid avanzar_celda_pid(int velocidad_objetivo) {\n    ticks_izq = 0; ticks_der = 0;\n    int last_error = 0;\n\n    long ticks_limite = TICKS_CELDA;\n    if (velocidad_objetivo &gt; 13000) ticks_limite -= 30; \n\n    while ((ticks_izq + ticks_der) / 2 &lt; ticks_limite) {\n        int d_L = leer(ADDR_L); \n        int d_R = leer(ADDR_R); \n        int d_F = leer(ADDR_F);\n\n        int dist_frenado = (velocidad_objetivo &gt; 13000) ? 70 : 45;\n        if (d_F &lt; dist_frenado &amp;&amp; d_F &gt; 0) break;\n\n\n        int error = 0;\n        bool pared_izq = (d_L &lt; UMBRAL_PARED_LAT &amp;&amp; d_L &gt; 0);\n        bool pared_der = (d_R &lt; UMBRAL_PARED_LAT &amp;&amp; d_R &gt; 0);\n        bool usar_paredes = true;\n\n        if (pared_izq &amp;&amp; pared_der) {\n\n            error = (d_L - SETPOINT_L) - (d_R - SETPOINT_R);\n        } \n        else if (pared_izq) {\n\n            error = (d_L - SETPOINT_L) * 2;\n        } \n        else if (pared_der) {\n\n            error = (SETPOINT_R - d_R) * 2;\n        } \n        else {\n\n            usar_paredes = false;\n            error = (ticks_izq - ticks_der) * KP_ENC; \n        }\n\n        if (abs(error) &lt; 4) error = 0;\n\n        int P = error * KP_PARED;\n        int D = (error - last_error) * KD_PARED;\n        if (!usar_paredes) D = 0; \n\n        last_error = error;\n\n        int correction = P + D;\n        if (correction &gt; CLAMP_PID) correction = CLAMP_PID;\n        if (correction &lt; -CLAMP_PID) correction = -CLAMP_PID;\n\n        set_motors(velocidad_objetivo - correction, velocidad_objetivo + correction);\n    }\n\n    set_motors(0, 0); \n    sleep_ms(velocidad_objetivo &gt; 13000 ? 10 : 50); \n}\n\nvoid girar_estatico(bool derecha) {\n    ticks_izq = 0; ticks_der = 0;\n    while ((ticks_izq + ticks_der) / 2 &lt; TICKS_GIRO) {\n        if(derecha) {\n            gpio_put(AIN1, 1); gpio_put(AIN2, 0); pwm_set_gpio_level(PWMA, VEL_GIRO);\n            gpio_put(BIN1, 0); gpio_put(BIN2, 1); pwm_set_gpio_level(PWMB, VEL_GIRO);\n        } else {\n            gpio_put(AIN1, 0); gpio_put(AIN2, 1); pwm_set_gpio_level(PWMA, VEL_GIRO);\n            gpio_put(BIN1, 1); gpio_put(BIN2, 0); pwm_set_gpio_level(PWMB, VEL_GIRO);\n        }\n    }\n    frenar_total();\n}\n\nvoid init_mapa() {\n    for(int x=0; x&lt;ANCHO; x++) {\n        for(int y=0; y&lt;ALTO; y++) {\n            mapa[x][y].paredes = 0;\n            mapa[x][y].distancia = 255; \n            mapa[x][y].visitada = false;\n        }\n    }\n    for(int x=0; x&lt;ANCHO; x++) { mapa[x][0].paredes |= PARED_S; mapa[x][ALTO-1].paredes |= PARED_N; }\n    for(int y=0; y&lt;ALTO; y++) { mapa[0][y].paredes |= PARED_W; mapa[ANCHO-1][y].paredes |= PARED_E; }\n\n    mapa[0][0].visitada = true;\n}\n\nvoid actualizar_flood_fill(bool modo_estricto) {\n\n    for(int x=0; x&lt;ANCHO; x++) \n        for(int y=0; y&lt;ALTO; y++) \n            mapa[x][y].distancia = 255;\n\n\n    mapa[5][5].distancia = 0; cola[0] = (Punto){5,5};\n    mapa[5][6].distancia = 0; cola[1] = (Punto){5,6};\n    mapa[6][5].distancia = 0; cola[2] = (Punto){6,5};\n    mapa[6][6].distancia = 0; cola[3] = (Punto){6,6};\n\n    int head = 0; int tail = 4; \n\n    while(head &lt; tail) {\n        Punto actual = cola[head++];\n        uint8_t dist_vecino = mapa[actual.x][actual.y].distancia + 1;\n\n        if (actual.y &lt; ALTO-1 &amp;&amp; !(mapa[actual.x][actual.y].paredes &amp; PARED_N)) {\n            if (!modo_estricto || mapa[actual.x][actual.y+1].visitada) { \n                if (mapa[actual.x][actual.y+1].distancia == 255) {\n                    mapa[actual.x][actual.y+1].distancia = dist_vecino;\n                    cola[tail++] = (Punto){actual.x, actual.y+1};\n                }\n            }\n        }\n        if (actual.y &gt; 0 &amp;&amp; !(mapa[actual.x][actual.y].paredes &amp; PARED_S)) {\n            if (!modo_estricto || mapa[actual.x][actual.y-1].visitada) {\n                if (mapa[actual.x][actual.y-1].distancia == 255) {\n                    mapa[actual.x][actual.y-1].distancia = dist_vecino;\n                    cola[tail++] = (Punto){actual.x, actual.y-1};\n                }\n            }\n        }\n\n        if (actual.x &lt; ANCHO-1 &amp;&amp; !(mapa[actual.x][actual.y].paredes &amp; PARED_E)) {\n            if (!modo_estricto || mapa[actual.x+1][actual.y].visitada) {\n                if (mapa[actual.x+1][actual.y].distancia == 255) {\n                    mapa[actual.x+1][actual.y].distancia = dist_vecino;\n                    cola[tail++] = (Punto){actual.x+1, actual.y};\n                }\n            }\n        }\n\n        if (actual.x &gt; 0 &amp;&amp; !(mapa[actual.x][actual.y].paredes &amp; PARED_W)) {\n            if (!modo_estricto || mapa[actual.x-1][actual.y].visitada) {\n                if (mapa[actual.x-1][actual.y].distancia == 255) {\n                    mapa[actual.x-1][actual.y].distancia = dist_vecino;\n                    cola[tail++] = (Punto){actual.x-1, actual.y};\n                }\n            }\n        }\n    }\n}\n\nvoid actualizar_paredes(int dir, bool existe) {\n    if (dir == NORTE &amp;&amp; robot_y &lt; ALTO-1) {\n        if(existe) { mapa[robot_x][robot_y].paredes |= PARED_N; mapa[robot_x][robot_y+1].paredes |= PARED_S; }\n    }\n    else if (dir == SUR &amp;&amp; robot_y &gt; 0) {\n        if(existe) { mapa[robot_x][robot_y].paredes |= PARED_S; mapa[robot_x][robot_y-1].paredes |= PARED_N; }\n    }\n    else if (dir == ESTE &amp;&amp; robot_x &lt; ANCHO-1) {\n        if(existe) { mapa[robot_x][robot_y].paredes |= PARED_E; mapa[robot_x+1][robot_y].paredes |= PARED_W; }\n    }\n    else if (dir == OESTE &amp;&amp; robot_x &gt; 0) {\n        if(existe) { mapa[robot_x][robot_y].paredes |= PARED_W; mapa[robot_x-1][robot_y].paredes |= PARED_E; }\n    }\n}\n\nvoid escanear_paredes() {\n    int f = leer(ADDR_F);\n    int r = leer(ADDR_R);\n    int l = leer(ADDR_L);\n\n    bool hay_f = (f &lt; UMBRAL_PARED_LAT &amp;&amp; f &gt; 0);\n    bool hay_r = (r &lt; UMBRAL_PARED_LAT &amp;&amp; r &gt; 0);\n    bool hay_l = (l &lt; UMBRAL_PARED_LAT &amp;&amp; l &gt; 0);\n\n    if(hay_f) actualizar_paredes(orientacion, true);\n    if(hay_r) actualizar_paredes((orientacion + 1) % 4, true);\n    if(hay_l) actualizar_paredes((orientacion + 3) % 4, true);\n\n    mapa[robot_x][robot_y].visitada = true;\n}\n\nvoid ejecutar_speed_run() {\n    printf(\"\\n--- MODO SPEED RUN ACTIVADO ---\\n\");\n    printf(\"TIENES 10 SEG PARA PONERME EN (0,0) NORTE\\n\");\n\n    for(int i=0; i&lt;10; i++) {\n        gpio_put(LED_PIN, 1); sleep_ms(200);\n        gpio_put(LED_PIN, 0); sleep_ms(800);\n    }\n\n    for(int i=0; i&lt;5; i++) { gpio_put(LED_PIN, 1); sleep_ms(50); gpio_put(LED_PIN, 0); sleep_ms(50); }\n\n    robot_x = 0; robot_y = 0; orientacion = NORTE;\n\n    actualizar_flood_fill(true);\n\n    while(1) {\n\n        if (mapa[robot_x][robot_y].distancia == 0) {\n            frenar_total();\n            printf(\"SPEED RUN COMPLETADO!!\\n\");\n            while(1) { gpio_put(LED_PIN, 1); sleep_ms(100); gpio_put(LED_PIN, 0); sleep_ms(100); }\n        }\n\n        int min_dist = 255;\n        int mejor_dir = -1;\n\n\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_N) &amp;&amp; robot_y &lt; ALTO-1) \n            if (mapa[robot_x][robot_y+1].distancia &lt; min_dist) { min_dist = mapa[robot_x][robot_y+1].distancia; mejor_dir = NORTE; }\n\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_E) &amp;&amp; robot_x &lt; ANCHO-1) \n            if (mapa[robot_x+1][robot_y].distancia &lt; min_dist) { min_dist = mapa[robot_x+1][robot_y].distancia; mejor_dir = ESTE; }\n\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_S) &amp;&amp; robot_y &gt; 0) \n            if (mapa[robot_x][robot_y-1].distancia &lt; min_dist) { min_dist = mapa[robot_x][robot_y-1].distancia; mejor_dir = SUR; }\n\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_W) &amp;&amp; robot_x &gt; 0) \n            if (mapa[robot_x-1][robot_y].distancia &lt; min_dist) { min_dist = mapa[robot_x-1][robot_y].distancia; mejor_dir = OESTE; }\n\n        if (mejor_dir == -1) {\n            frenar_total();\n            printf(\"ERROR: RUTA BLOQUEADA EN SPEED RUN\\n\"); break;\n        }\n\n        centrar_frente_a_pared(); \n\n        int diferencia = (mejor_dir - orientacion + 4) % 4;\n        if (diferencia == 1) { girar_estatico(true); orientacion = (orientacion + 1) % 4; }\n        else if (diferencia == 3) { girar_estatico(false); orientacion = (orientacion + 3) % 4; }\n        else if (diferencia == 2) { girar_estatico(true); girar_estatico(true); orientacion = (orientacion + 2) % 4; }\n\n        avanzar_celda_pid(VEL_SPEED_RUN);\n\n        if (orientacion == NORTE) robot_y++;\n        else if (orientacion == SUR) robot_y--;\n        else if (orientacion == ESTE) robot_x++;\n        else if (orientacion == OESTE) robot_x--;\n    }\n}\n\nint main() {\n    setup_system();\n    init_mapa();\n    sleep_ms(3000); \n\n    printf(\"--- FASE 1: EXPLORACION ---\\n\");\n\n    while (1) {\n        escanear_paredes();\n        actualizar_flood_fill(false); \n\n\n        if (mapa[robot_x][robot_y].distancia == 0) {\n            frenar_total();\n            printf(\"META ENCONTRADA. PREPARANDO FASE 2...\\n\");\n\n            for(int i=0; i&lt;4; i++) { girar_estatico(true); }\n\n            ejecutar_speed_run(); \n            break; \n        }\n\n        uint8_t min_dist = 255;\n\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_N) &amp;&amp; robot_y &lt; ALTO-1) if (mapa[robot_x][robot_y+1].distancia &lt; min_dist) min_dist = mapa[robot_x][robot_y+1].distancia;\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_E) &amp;&amp; robot_x &lt; ANCHO-1) if (mapa[robot_x+1][robot_y].distancia &lt; min_dist) min_dist = mapa[robot_x+1][robot_y].distancia;\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_S) &amp;&amp; robot_y &gt; 0) if (mapa[robot_x][robot_y-1].distancia &lt; min_dist) min_dist = mapa[robot_x][robot_y-1].distancia;\n        if (!(mapa[robot_x][robot_y].paredes &amp; PARED_W) &amp;&amp; robot_x &gt; 0) if (mapa[robot_x-1][robot_y].distancia &lt; min_dist) min_dist = mapa[robot_x-1][robot_y].distancia;\n\n        int intentos[4] = {orientacion, (orientacion+1)%4, (orientacion+3)%4, (orientacion+2)%4};\n        int mejor_dir = -1;\n        bool encontrado_nuevo = false;\n\n        for(int i=0; i&lt;4; i++) {\n            int dir = intentos[i];\n            int nx = robot_x, ny = robot_y;\n            bool pared = false;\n            if (dir==NORTE) { ny++; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_N); }\n            else if (dir==ESTE) { nx++; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_E); }\n            else if (dir==SUR) { ny--; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_S); }\n            else if (dir==OESTE) { nx--; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_W); }\n\n            if (nx &gt;= 0 &amp;&amp; nx &lt; ANCHO &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; ALTO &amp;&amp; !pared) {\n                if (mapa[nx][ny].distancia == min_dist &amp;&amp; !mapa[nx][ny].visitada) {\n                    mejor_dir = dir; encontrado_nuevo = true; break;\n                }\n            }\n        }\n        if (!encontrado_nuevo) {\n            for(int i=0; i&lt;4; i++) {\n                int dir = intentos[i];\n                int nx = robot_x, ny = robot_y;\n                bool pared = false;\n                if (dir==NORTE) { ny++; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_N); }\n                else if (dir==ESTE) { nx++; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_E); }\n                else if (dir==SUR) { ny--; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_S); }\n                else if (dir==OESTE) { nx--; pared = (mapa[robot_x][robot_y].paredes &amp; PARED_W); }\n\n                if (nx &gt;= 0 &amp;&amp; nx &lt; ANCHO &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; ALTO &amp;&amp; !pared) {\n                    if (mapa[nx][ny].distancia == min_dist) { mejor_dir = dir; break; }\n                }\n            }\n        }\n\n\n        centrar_frente_a_pared();\n\n        if (mejor_dir == -1) {\n            girar_estatico(true); girar_estatico(true);\n            orientacion = (orientacion + 2) % 4;\n        } else {\n            int diferencia = (mejor_dir - orientacion + 4) % 4;\n            if (diferencia == 1) { girar_estatico(true); orientacion = (orientacion + 1) % 4; }\n            else if (diferencia == 3) { girar_estatico(false); orientacion = (orientacion + 3) % 4; }\n            else if (diferencia == 2) { girar_estatico(true); girar_estatico(true); orientacion = (orientacion + 2) % 4; }\n        }\n\n        avanzar_celda_pid(VEL_EXPLORACION);\n\n        if (orientacion == NORTE) robot_y++;\n        else if (orientacion == SUR) robot_y--;\n        else if (orientacion == ESTE) robot_x++;\n        else if (orientacion == OESTE) robot_x--;\n\n        sleep_ms(50);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"SE/PoyectoF/#esquema","title":"Esquema","text":""},{"location":"SE/PoyectoF/#video","title":"Video","text":""},{"location":"SE/Tarea1/","title":"An\u00e1lisis de microcontroladores enfocado en un proyecto","text":""},{"location":"SE/Tarea1/#proyecto","title":"Proyecto","text":"<p>Sistema de reconocimiento de voz b\u00e1sico</p> <p>El proyecto consiste en implementar un sistema embebido capaz de reconocer comandos de voz simples, ejemplo: \u201cencender\u201d, \u201capagar\u201d, \u201csubir\u201d, \u201cbajar\u201d, y ejecutar acciones predefinidas como activar un LED, encender un ventilador, abrir una puerta o controlar dispositivos del hogar.</p>"},{"location":"SE/Tarea1/#microcontroladores","title":"Microcontroladores","text":"<p>Para elegir los microcontroladores m\u00e1s adecuados para un proyecto de reconocimiento de voz, se prioriz\u00f3 que tuvieran capacidad de procesar audio de una mejor manera, as\u00ed como memoria suficiente para ejecutar modelos de reconocimiento de voz de manera eficiente. Lo que facilita el desarrollo y permite implementar funcionalidades de forma m\u00e1s r\u00e1pida y confiable.</p> <p>Microcontroladores escogidos:</p> <ul> <li>nRF52840</li> <li>ESP32</li> <li>STM32F407</li> <li>RP2040</li> </ul>"},{"location":"SE/Tarea1/#tabla-comparativa","title":"Tabla comparativa","text":"Microcontrolador Arquitectura Velocidad de trabajo Memoria Perif\u00e9ricos Costo aprox. (MX) Ecosistema ESP32 Xtensa LX6/LX7 dual-core (32-bit) Hasta 240 MHz 520 KB SRAM + PSRAM externa Wi-Fi, Bluetooth, I\u00b2S (audio) $150-200 ESP-IDF, Arduino, ESP-SR, TensorFlow Lite Micro STM32F407 ARM Cortex-M4F (32-bit, con FPU) 168 MHz 1 MB Flash, 192 KB SRAM I\u00b2S, ADC, timers DSP $200-250 STM32CubeIDE, CubeMX, CMSIS-DSP, TensorFlow Lite Micro nRF52840 ARM Cortex-M4F (32-bit) 64 MHz 1 MB Flash, 256 KB RAM Bluetooth 5 LE, ADC, I\u00b2S $225-240 nRF Connect SDK, Zephyr RTOS, TensorFlow Lite Micro RP2040 ARM Cortex-M0+ dual-core (32-bit) 133 MHz 264 KB SRAM + Flash externa PIO, ADC, USB, I\u00b2C/SPI/UART $200-260 Pico SDK (C/C++), MicroPython, TensorFlow Lite Micro"},{"location":"SE/Tarea1/#definiciones","title":"Definiciones","text":"<ul> <li>Arquitectura: La arquitectura de un microcontrolador define su estructura funcional y c\u00f3mo se organizan sus componentes internos para realizar tareas de procesamiento y control.  </li> <li>Velocidad de trabajo: Se refiere a la frecuencia a la que el microcontrolador ejecuta instrucciones, medida en hercios (Hz).  </li> <li>Memoria: La memoria de un microcontrolador es un componente esencial que almacena tanto las instrucciones del programa como los datos necesarios para su ejecuci\u00f3n.  </li> <li>Perif\u00e9ricos: Los perif\u00e9ricos para un microcontrolador son circuitos digitales integrados dentro del chip que permiten la interacci\u00f3n con el mundo exterior y la realizaci\u00f3n de funciones espec\u00edficas sin necesidad de componentes externos adicionales.  </li> <li>Ecosistema: El ecosistema se refiere al conjunto de elementos y componentes necesarios para su funcionamiento y desarrollo, que van desde el hardware hasta el software y las herramientas de programaci\u00f3n.  </li> </ul>"},{"location":"SE/Tarea1/#comparativa","title":"Comparativa","text":"<p>El ESP32 sobresale como una de las mejores opciones debido a su equilibrio entre potencia, conectividad y costo. Incorpora Wi-Fi y Bluetooth, y cuenta con librer\u00edas espec\u00edficas para reconocimiento de voz. Esto permite un desarrollo r\u00e1pido y con gran respaldo de la comunidad.  </p> <p>El STM32F407, por su parte, ofrece mayor robustez en el procesamiento digital de se\u00f1ales, aunque carece de conectividad inal\u00e1mbrica integrada y presenta un costo m\u00e1s alto.  </p> <p>El nRF52840 resulta atractivo para aplicaciones port\u00e1tiles o de bajo consumo, ya que integra Bluetooth Low Energy y dispone de suficiente memoria para modelos peque\u00f1os de reconocimiento de voz. Sin embargo, su frecuencia de trabajo m\u00e1s baja limita su rendimiento en tiempo real.  </p> <p>En contraste, el RP2040 destaca por su bajo precio y amplia comunidad maker, lo que lo hace ideal para prototipado y proyectos educativos, aunque no es el m\u00e1s indicado para aplicaciones de voz intensivas debido a su memoria reducida y falta de conectividad integrada.  </p>"},{"location":"SE/Tarea1/#ranking","title":"Ranking","text":"<ol> <li>ESP32  </li> <li>STM32F407  </li> <li>nRF52840  </li> <li>RP2040  </li> </ol>"},{"location":"SE/Tarea1/#conclusion","title":"Conclusi\u00f3n","text":"<p>El ESP32 es la alternativa m\u00e1s conveniente para este proyecto, pues combina conectividad, soporte espec\u00edfico para reconocimiento de voz y facilidad de implementaci\u00f3n.  </p> <p>El STM32F407 es recomendable si se busca un mayor control y precisi\u00f3n en el procesamiento de audio, mientras que el nRF5284 es id\u00f3neo para aplicaciones port\u00e1tiles de bajo consumo, y el RP2040 queda como una opci\u00f3n econ\u00f3mica para pruebas o entornos de aprendizaje.</p>"},{"location":"SE/Tarea10/","title":"Terminal con instrucci\u00f3n \"LED ON - LED OFF\"","text":"<p>Este c\u00f3digo permite controlar el encendido y apagado de un LED desde el monitor serial. El usuario escribe los comandos \u201cLED ON\u201d o \u201cLED OFF\u201d en la terminal, y el microcontrolador ejecuta la acci\u00f3n correspondiente.</p> <p>C\u00f3digo Recepci\u00f3n</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n\n#define BOTON1 16\n#define BOTON2 19\n#define MOTOR 0\n#define F_PWM_HZ 2000   // 2 kHz: fuera del rango visible\n#define TOP 1023        // 10 bits de resoluci\u00f3n\n\nint BOTON1ESTADO=0;\nint BOTON2ESTADO=0;\n\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(MOTOR, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(MOTOR);\n    uint chan  = pwm_gpio_to_channel(MOTOR);\n\n    // Calcular divisor\n    float f_clk = 150000000.0f; // 125 MHz\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 1023);\n    pwm_set_enabled(slice, true);\n\n\n    gpio_init(BOTON1); gpio_set_dir(BOTON1,0);\n    gpio_init(BOTON2); gpio_set_dir(BOTON2,0);\n\n    int velocidades[3]={250,512,1023};\n    int velocidad_actual=0;\n\n    while (true) {\n        BOTON1ESTADO=gpio_get(BOTON1);\n        BOTON2ESTADO=gpio_get(BOTON2);\n\n        if (BOTON1ESTADO==1){\n            velocidad_actual++;\n            if (velocidad_actual&gt;2){\n                velocidad_actual=0;\n            }\n            pwm_set_chan_level(slice, chan, velocidades[velocidad_actual]);\n            sleep_ms(300);\n        }\n\n        if (BOTON2ESTADO==1){\n            velocidad_actual--;\n            if (velocidad_actual&lt;0){\n                velocidad_actual=2;\n            }\n            pwm_set_chan_level(slice, chan, velocidades[velocidad_actual]);\n            sleep_ms(300);\n        }\n\n        sleep_ms(10);\n\n\n    }\n}\n</code></pre> <p>C\u00f3digo Env\u00edo</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\nusing namespace std;\n\nstring mensaje = \"\";\n\nint main() {\n    stdio_init_all();\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    sleep_ms(2000);\n    printf(\"\\nConexi\u00f3n lista. Escribe 'on;' o 'off;'.\\n\");\n\n    while (true) {\n        int ch_int = getchar_timeout_us(10000);\n\n        if (ch_int == PICO_ERROR_TIMEOUT) {\n            continue;\n        }\n\n        char ch = (char)ch_int;\n\n        if (ch == '\\r' || ch == '\\n') {\n            continue;\n        }\n\n        mensaje += ch;\n\n        if (ch == ';') {\n            string comando = mensaje.substr(0, mensaje.length() - 1);\n\n            if (comando == \"on\" || comando == \"off\") {\n                printf(\"Instrucci\u00f3n: %s\\n\", mensaje.c_str());\n                uart_puts(UART_ID, mensaje.c_str());\n            } else {\n                printf(\"Instrucci\u00f3n inv\u00e1lida: '%s'\\n\", comando.c_str());\n            }\n\n            mensaje = \"\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"SE/Tarea10/#video","title":"Video","text":""},{"location":"SE/Tarea11/","title":"ADC L\u00faxometro","text":""},{"location":"SE/Tarea11/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Crear un codigo que me marca la luminosidad de 0-100% usando un LDR</p>"},{"location":"SE/Tarea11/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n\n#define ADC_INPUT 1  \n#define N_muestras 16      \n\nint main() {\n    stdio_init_all();\n    adc_init();\n    adc_gpio_init(27);\n    adc_select_input(ADC_INPUT);\n\n    uint16_t buffer[N_muestras];\n    uint32_t sum = 0;\n    uint8_t indice = 0;\n    uint8_t cuenta = 0;\n\n    while (true) {\n        uint16_t adc = adc_read();\n        if (cuenta &lt; N_muestras) {\n            buffer[indice] = adc;\n            sum += adc;\n            cuenta++;\n            indice++;\n        } else {\n            sum -= buffer[indice];\n            buffer[indice] = adc;\n            sum += adc;\n\n            indice++;\n            if (indice &gt;= N_muestras) indice = 0;\n\n            uint16_t promedio = sum / N_muestras;\n\n            float porcentaje = (promedio * 100.0f) / 4095;\n\n            printf(\"Luz: %u%%\\n\", (int)porcentaje);\n\n            sleep_ms(200);\n        }\n    }\n}\n</code></pre>"},{"location":"SE/Tarea11/#esquema","title":"Esquema","text":""},{"location":"SE/Tarea11/#video","title":"Video","text":""},{"location":"SE/Tarea12/","title":"Servo con ADC","text":""},{"location":"SE/Tarea12/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Crear un codigo para mover un servo usando un potenciometro y un adc que vaya 0-180 grados</p> <p>INFO IMPORTANTE</p> <p>El movimiento de un servo requiere alimentacion 5-6v y en el pin de signal, un pwm a 50 HZ con un pulso de 1-2ms que representa 0-180 grados</p>"},{"location":"SE/Tarea12/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/pwm.h\"\n\n#define SERVO_PIN 1    \n#define ADC_INPUT 0    \n#define N_muestras 16    \n\n#define TOP 1023        \n#define F_SERVO_HZ 50    \n\n#define SERVO_MIN 51      \n#define SERVO_MAX 102  \n\nint main() {\n    stdio_init_all();\n    adc_init();\n    adc_gpio_init(27);\n    adc_select_input(ADC_INPUT);\n\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);\n    uint chan = pwm_gpio_to_channel(SERVO_PIN);\n\n    float f_clk = 125000000.0f;\n    float div = f_clk / (F_SERVO_HZ * (TOP + 1));\n    pwm_set_wrap(slice, TOP);\n    pwm_set_clkdiv(slice, div);\n    pwm_set_enabled(slice, true);\n\n    uint16_t buffer[N_muestras];\n    uint32_t suma = 0;\n    uint8_t indice = 0;\n    uint8_t cuenta = 0;\n\n\n    while (true) {\n        uint16_t lectura = adc_read();\n\n        if (cuenta &lt; N_muestras) {\n            buffer[indice] = lectura;\n            suma += lectura;\n            cuenta++;\n            indice++;\n        } else {\n            suma -= buffer[indice];\n            buffer[indice] = lectura;\n            suma += lectura;\n            indice++;\n            if (indice &gt;= N_muestras) indice = 0;\n\n            uint16_t promedio = suma / N_muestras;\n            uint16_t pulso = SERVO_MIN + (promedio * (SERVO_MAX - SERVO_MIN)) / 4095;\n            pwm_set_chan_level(slice, chan, pulso);\n\n            uint16_t grados = (promedio * 180) / 4095;\n\n            printf(\"Grados: %u\u00b0\\n\", grados);\n\n            sleep_ms(200);\n        }\n    }\n}\n</code></pre>"},{"location":"SE/Tarea12/#esquema","title":"Esquema","text":""},{"location":"SE/Tarea12/#video","title":"Video","text":""},{"location":"SE/Tarea2/","title":"Outputs basicos","text":""},{"location":"SE/Tarea2/#contador-binario-4-bits","title":"Contador binario 4 bits","text":""},{"location":"SE/Tarea2/#que-debe-hacer","title":"Que debe hacer","text":"<p>En cuatro leds debe mostrarse cad segundo la representacion binaria del 0 al 15</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define PIN_A 0\n#define PIN_B 1\n#define PIN_C 2\n#define PIN_D 3\n\nint main() {\n\n   // M\u00e1scara\n   const uint32_t MASK = (1u&lt;&lt;PIN_A) | (1u&lt;&lt;PIN_B) | (1u&lt;&lt;PIN_C) | (1u&lt;&lt;PIN_D);\n\n   gpio_init_mask(MASK);\n   gpio_set_dir_out_masked(MASK);\n\n   while (true) {\n       for (int i = 0; i &lt; 16; i++) {   // Cuenta de 0 a 15\n           gpio_put_masked(MASK, i &lt;&lt; PIN_A);\n\n           sleep_ms(1000);                  \n       }\n   }\n}\n</code></pre>"},{"location":"SE/Tarea2/#esquemtico","title":"Esquemtico","text":""},{"location":"SE/Tarea2/#video","title":"Video","text":""},{"location":"SE/Tarea2/#barrido-de-leds","title":"Barrido de leds","text":""},{"location":"SE/Tarea2/#que-debe-hacer_1","title":"Que debe hacer","text":"<p>Correr un \u201c1\u201d por cinco LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921\u2026)</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\n#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n\nint main() {\n   // M\u00e1scara\n   const uint32_t MASK = (1u&lt;&lt;LED0) | (1u&lt;&lt;LED1) | (1u&lt;&lt;LED2) | (1u&lt;&lt;LED3);\n\n   // Inicializar pines\n   gpio_init(LED0);\n   gpio_init(LED1);\n   gpio_init(LED2);\n   gpio_init(LED3);\n\n   // Configurar como salida\n   sio_hw-&gt;gpio_oe_set = MASK;\n\n   int pos = 0;       // LED inicial\n   int dir = 1;       // Direcci\u00f3n: 1\u2192derecha, -1\u2192izquierda\n\n   while (true) {\n       // Apagar todos\n       sio_hw-&gt;gpio_clr = MASK;\n\n       // Encender solo el LED actual\n       sio_hw-&gt;gpio_set = (1u &lt;&lt; pos);\n\n       sleep_ms(200);\n\n       // Mover posici\u00f3n\n       pos += dir;\n\n       // Rebotar en los extremos\n       if (pos == 3) dir = -1;  \n       if (pos == 0) dir = 1;\n   }\n}\n</code></pre>"},{"location":"SE/Tarea2/#esquemtico_1","title":"Esquemtico","text":""},{"location":"SE/Tarea2/#video_1","title":"Video","text":""},{"location":"SE/Tarea3/","title":"Inputs","text":""},{"location":"SE/Tarea3/#compuertas-basicas-and-or-xor-con-2-botones","title":"Compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":""},{"location":"SE/Tarea3/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define BTN_A   5   \n#define BTN_B   4   \n#define LED_AND 0   \n#define LED_OR  1   \n#define LED_XOR 2   \n\nint main() {\n\n    const uint32_t BTN_MASK = (1u &lt;&lt; BTN_A) | (1u &lt;&lt; BTN_B);\n    const uint32_t LED_MASK = (1u &lt;&lt; LED_AND) | (1u &lt;&lt; LED_OR) | (1u &lt;&lt; LED_XOR);\n\n    gpio_init_mask(BTN_MASK | LED_MASK);\n    gpio_set_dir_out_masked(LED_MASK);  \n    gpio_set_dir_in_masked(BTN_MASK);   \n    gpio_pull_up(BTN_A);\n    gpio_pull_up(BTN_B);\n\n    while (true) {\n\n        int a = !gpio_get(BTN_A);\n        int b = !gpio_get(BTN_B);\n\n\n        int val_and = a &amp; b;\n        int val_or  = a | b;\n        int val_xor = a ^ b;\n\n\n        uint32_t leds = (val_and &lt;&lt; LED_AND) | (val_or &lt;&lt; LED_OR) | (val_xor &lt;&lt; LED_XOR);\n\n        gpio_put_masked(LED_MASK, leds);\n\n        sleep_ms(20);\n    }\n}\n</code></pre>"},{"location":"SE/Tarea3/#esquematico","title":"Esquematico","text":""},{"location":"SE/Tarea3/#video","title":"Video","text":""},{"location":"SE/Tarea3/#selector-ciclico-de-4-leds-con-avanceretroceso","title":"Selector c\u00edclico de 4 LEDs con avance/retroceso","text":""},{"location":"SE/Tarea3/#que-debe-hacer_1","title":"Qu\u00e9 debe hacer","text":"<p>Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n#define B_AV 4\n#define B_RE 5\n\nint main() {\n    // M\u00e1scara\n    const uint32_t LEDS_MASK = (1u&lt;&lt;LED0) | (1u&lt;&lt;LED1) | (1u&lt;&lt;LED2) | (1u&lt;&lt;LED3);\n\n    gpio_init(LED0);\n    gpio_init(LED1);\n    gpio_init(LED2);\n    gpio_init(LED3);\n    gpio_set_dir(LED0, true);\n    gpio_set_dir(LED1, true);\n    gpio_set_dir(LED2, true);\n    gpio_set_dir(LED3, true);\n\n    gpio_init(B_AV);\n    gpio_init(B_RE);\n    gpio_set_dir(B_AV, false);\n    gpio_set_dir(B_RE, false);\n    gpio_pull_up(B_AV);\n    gpio_pull_up(B_RE);\n\n    int pos = 0;        \n    int estadoAV = 1;   // Estado previo bot\u00f3n A\n    int estadoRE = 1;   // Estado previo bot\u00f3n B\n\n    while (true) {\n\n        gpio_put_masked(LEDS_MASK, (1u &lt;&lt; pos));\n\n        if (gpio_get(B_AV) == 0 &amp;&amp; estadoAV == 1) {\n            pos++;\n            if (pos &gt; 3) pos = 0;\n        }\n        else if (gpio_get(B_RE) == 0 &amp;&amp; estadoRE == 1) {\n            pos--;\n            if (pos &lt; 0) pos = 3;\n        }\n        // Guardar estado\n        estadoAV = gpio_get(B_AV);\n        estadoRE = gpio_get(B_RE);\n\n        sleep_ms(20);\n    }\n}\n</code></pre>"},{"location":"SE/Tarea3/#esquematico_1","title":"Esquematico","text":""},{"location":"SE/Tarea3/#video_1","title":"Video","text":""},{"location":"SE/Tarea4/","title":"Interruptores","text":""},{"location":"SE/Tarea4/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p> <p>Reglas del juego</p> <ol> <li> <p>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> </li> <li> <p>Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> <ul> <li> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> </li> <li> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> </li> <li> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> </li> <li> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> </li> </ul> </li> <li> <p>Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> </li> <li> <p>Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> </li> <li> <p>Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> </li> <li> <p>Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p> </li> </ol> <pre><code>#include \"pico/stdlib.h\"\n\n#define LED_1 0\n#define LED_2 1\n#define LED_3 2\n#define LED_4 3\n#define LED_5 4\n\n//Jugadores\n#define LED_J1 5\n#define LED_J2 6\n\n#define BTN_D 8 // Bot\u00f3n derecho\n#define BTN_I 7 // Bot\u00f3n izquierdo\n\n// Estado de la pelota\nint led_on = LED_3;\nint direc = 0;\n\nint boton_d = 0;\nint boton_i = 0;\n\n\nvoid botones_dir(uint gpio, uint32_t events) {\n    if (gpio == BTN_D) boton_d = 1;\n    if (gpio == BTN_I) boton_i = 1;\n}\n\n// Led ganador\nvoid parpadeo(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(300);\n        gpio_put(led, 0);\n        sleep_ms(300);\n    }\n}\n\nvoid init_pins() {\n    for (int i = LED_1; i &lt;= LED_5; i++) {\n        gpio_init(i);\n        gpio_set_dir(i, true);\n    }\n\n    gpio_init(LED_J1);\n    gpio_set_dir(LED_J1, true);\n    gpio_init(LED_J2);\n    gpio_set_dir(LED_J2, true);\n\n    gpio_init(BTN_D);\n    gpio_set_dir(BTN_D, false);\n    gpio_pull_up(BTN_D);\n    gpio_init(BTN_I);\n    gpio_set_dir(BTN_I, false);\n    gpio_pull_up(BTN_I);\n\n    gpio_set_irq_enabled_with_callback(BTN_D, GPIO_IRQ_EDGE_FALL, true, &amp;botones_dir);\n    gpio_set_irq_enabled_with_callback(BTN_I, GPIO_IRQ_EDGE_FALL, true, &amp;botones_dir);\n}\n\nint main() {\n    stdio_init_all();\n    init_pins();\n\n    while (direc == 0) {\n        gpio_put(LED_3, 1);\n        if (boton_d) { direc = -1; boton_d = 0; } // Empieza bot\u00f3n derecho\n        if (boton_i) { direc = +1;  boton_i = 0; } // Empieza bot\u00f3n izquierdo\n        sleep_ms(100);\n    }\n\n    while (true) {\n\n        for (int i = LED_1; i &lt;= LED_5; i++) gpio_put(i, 0);\n        gpio_put(led_on, 1);\n        sleep_ms(800); // Velocidad\n\n        if (led_on == LED_1) {\n            if (boton_d) { direc = 1; }\n            else { parpadeo(LED_J2); led_on = LED_3; direc = 1; } // Punto jugador derecho\n            boton_d = 0;\n        }\n        else if (led_on == LED_5) {\n            if (boton_i) { direc = -1; }\n            else { parpadeo(LED_J1); led_on = LED_3; direc = -1; } // Punto jugador izquierdo\n            boton_i = 0;\n        }\n\n        // Mover pelota\n        led_on += direc;\n\n        // Limite\n        if (led_on &lt; LED_1) led_on = LED_1;\n        if (led_on &gt; LED_5) led_on = LED_5;\n    }\n}\n</code></pre>"},{"location":"SE/Tarea4/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"SE/Tarea4/#video","title":"Video","text":""},{"location":"SE/Tarea5/","title":"Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":""},{"location":"SE/Tarea5/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> <ul> <li> <p>Periodo promedio y tolerancia.</p> </li> <li> <p>Jitter pico-a-pico y, si tu equipo lo permite, RMS.</p> </li> <li> <p>Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</p> </li> </ul> <p><pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 0\nstatic const int BLINK_MS = 50;\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre> Para comprobar el funcionamiento del generador de onda cuadrada mediante el toggle de un pin de salida controlado por la ISR de ALARM0, se realiz\u00f3 la medici\u00f3n con el osciloscopio Tektronix (modelo digital). Se configur\u00f3 el rearme acumulativo de la alarma con un periodo nominal definido en 50 ms.</p> <p>En el esquema se muestra la forma de onda obtenida del osciloscopio.</p>"},{"location":"SE/Tarea5/#esquema","title":"Esquema","text":"<ul> <li>Periodo promedio medido: 49.94 ms</li> <li>Tolerancia: aproximadamente \u00b10.56 ms</li> <li>Jitter pico-a-pico: ~560 \u00b5s</li> </ul> <ul> <li>Acoplamiento: CC</li> <li>Escala de tiempo: 20 ms/div y 10 ms/div</li> <li>Escala de voltaje: 1 V/div.</li> <li>Modo de disparo: flanco, canal 1, nivel medio de la se\u00f1al (~1.3 V)</li> </ul> <p>tarea 5 ejercicio 1</p>"},{"location":"SE/Tarea5/#comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":""},{"location":"SE/Tarea5/#que-debe-hacer_1","title":"Qu\u00e9 debe hacer","text":"<p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <ul> <li> <p>Usa rearme acumulativo.</p> </li> <li> <p>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico.</p> </li> <li> <p>Con el osciloscopio, mide y registra para cada modo:</p> <ul> <li>Periodo promedio y desviaci\u00f3n respecto al nominal.</li> <li>Jitter pico-a-pico y/o RMS.</li> <li>Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</li> </ul> </li> </ul>"},{"location":"SE/Tarea5/#codigo-modo-s","title":"C\u00f3digo modo \u00b5s","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 0\nstatic const int BLINK_MS = 50;\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"SE/Tarea5/#codigo-modo-ciclos","title":"C\u00f3digo modo ciclos","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     0\n\n// Calcula el n\u00famero de IRQ para esa alarma\n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 50000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1. Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2. Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3. Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre> <p>Se gener\u00f3 una se\u00f1al cuadrada mediante el toggle de un pin en la ISR de ALARM0, empleando rearme acumulativo. Se program\u00f3 el mismo periodo nominal en dos configuraciones:</p> <ol> <li> <p>Modo \u00b5s (resoluci\u00f3n en microsegundos).</p> </li> <li> <p>Modo ciclos de clk_sys (resoluci\u00f3n en ciclos de reloj).</p> </li> </ol> <p>En ambos casos se mantuvo id\u00e9ntico el resto del c\u00f3digo.</p>"},{"location":"SE/Tarea5/#esquema-modo-s","title":"Esquema modo \u00b5s","text":""},{"location":"SE/Tarea5/#esquema-modo-ciclos","title":"Esquema modo ciclos","text":""},{"location":"SE/Tarea5/#resultado-de-medicion-con-osciloscopio","title":"Resultado de medici\u00f3n con osciloscopio","text":"<ol> <li>Modo \u00b5s<ul> <li>Periodo nominal configurado: 50 ms</li> <li>Periodo promedio medido: 49.94 ms</li> <li>Desviaci\u00f3n: ~1.1%</li> <li>Jitter pico-a-pico: ~560 \u00b5s</li> </ul> </li> </ol> <ol> <li>Modo ciclos<ul> <li>Periodo nominal configurado: 50 000 (Periodo en ms)</li> <li>Periodo promedio medido: 49.96 ms</li> <li>Desviaci\u00f3n: ~0.08%</li> <li>Jitter pico-a-pico: ~14 \u00b5s</li> </ul> </li> </ol> <p>En modo \u00b5s, el temporizador est\u00e1 limitado por la resoluci\u00f3n del tick de microsegundo. Esto produce un jitter m\u00e1s grande. La ventaja es que permite programar periodos largos sin desbordar el contador.</p> <p>En modo ciclos, la resoluci\u00f3n es mucho m\u00e1s fina. El resultado es un jitter significativamente menor y una desviaci\u00f3n m\u00e1s peque\u00f1a respecto al periodo nominal. Sin embargo, el horizonte de programaci\u00f3n es m\u00e1s corto, el contador puede desbordarse m\u00e1s r\u00e1pido si se intentan programar retardos largos \u00fanicamente con ciclos.</p> <p>tarea 5 ejercicio 2</p>"},{"location":"SE/Tarea5/#cuatro-alarmas-leds-a-distintas-frecuencias","title":"Cuatro alarmas / LEDs a distintas frecuencias","text":""},{"location":"SE/Tarea5/#que-debe-hacer_2","title":"Qu\u00e9 debe hacer","text":"<p>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio.</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN0      0\n#define LED_PIN1      1\n#define LED_PIN2      2\n#define LED_PIN3      3\n\n\n#define ALARM_NUM0     0  // usaremos la alarma 0\n#define ALARM_NUM1     1\n#define ALARM_NUM2     2\n#define ALARM_NUM3     3\n\n// Calcula el n\u00famero de IRQ para esa alarma\n#define ALARM0_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM0)\n\nstatic volatile uint32_t next_deadline[4];   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us[4]=  { // periodo en microsegundos\n    50000u,\n    100000u,\n    150000u,\n    200000u  \n};\n\nvoid on_alarm_irq(void) {\n    if (timer_hw-&gt;intr &amp; (1u &lt;&lt; ALARM_NUM0)) {\n        hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM0);\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN0;\n        next_deadline[0] += intervalo_us[0];\n        timer_hw-&gt;alarm[ALARM_NUM0] = next_deadline[0];\n    }\n\n    if (timer_hw-&gt;intr &amp; (1u &lt;&lt; ALARM_NUM1)) {\n        hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM1);\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN1;\n        next_deadline[1] += intervalo_us[1];\n        timer_hw-&gt;alarm[ALARM_NUM1] = next_deadline[1];\n    }\n\n    if (timer_hw-&gt;intr &amp; (1u &lt;&lt; ALARM_NUM2)) {\n        hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM2);\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN2;\n        next_deadline[2] += intervalo_us[2];\n        timer_hw-&gt;alarm[ALARM_NUM2] = next_deadline[2];\n    }\n\n    if (timer_hw-&gt;intr &amp; (1u &lt;&lt; ALARM_NUM3)) {\n        hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM3);\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN3;\n        next_deadline[3] += intervalo_us[3];\n        timer_hw-&gt;alarm[ALARM_NUM3] = next_deadline[3];\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN0);\n    gpio_set_dir(LED_PIN0, true);\n    gpio_init(LED_PIN1);\n    gpio_set_dir(LED_PIN1, true);\n    gpio_init(LED_PIN2);\n    gpio_set_dir(LED_PIN2, true);\n    gpio_init(LED_PIN3);\n    gpio_set_dir(LED_PIN3, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n\n    next_deadline[0] = now_us + intervalo_us[0];\n    next_deadline[1] = now_us + intervalo_us[1];\n    next_deadline[2] = now_us + intervalo_us[2];\n    next_deadline[3] = now_us + intervalo_us[3];      \n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM0] = next_deadline[0];\n    timer_hw-&gt;alarm[ALARM_NUM1] = next_deadline[1];\n    timer_hw-&gt;alarm[ALARM_NUM2] = next_deadline[2];\n    timer_hw-&gt;alarm[ALARM_NUM3] = next_deadline[3];\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm_irq);\n\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM0);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM1);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM2);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM3);\n\n   //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM0_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"SE/Tarea5/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"SE/Tarea5/#video","title":"Video","text":""},{"location":"SE/Tarea7/","title":"Sim\u00f3n Dice (4 colores) \u2013 RP Pico 2","text":""},{"location":"SE/Tarea7/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> <ul> <li> <p>La secuencia crece +1 por ronda, de 1 hasta 15.</p> </li> <li> <p>La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda.</p> </li> <li> <p>Tiempo l\u00edmite por ronda (fase de entrada): TL = longitud + 5 segundos (p. ej., Ronda 7 \u2192 12 s).</p> </li> <li> <p>Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</p> </li> <li> <p>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</p> </li> </ul> <p>Reglas del juego (obligatorias)</p> <ol> <li> <p>Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</p> </li> <li> <p>Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</p> </li> <li> <p>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</p> </li> <li> <p>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</p> </li> <li> <p>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</p> </li> <li> <p>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</p> </li> </ol> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n#include \"pico/time.h\"\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\n#define LED_0 0\n#define LED_1 1\n#define LED_2 4\n#define LED_3 5\n\n#define B_0 15\n#define B_1 14\n#define B_2 13\n#define B_3 12\n\n#define SEG_A 18\n#define SEG_B 17\n#define SEG_C 9\n#define SEG_D 10\n#define SEG_E 11\n#define SEG_F 19\n#define SEG_G 20\n\n#define RONDAS 15          // N\u00famero de rondas\n#define LED_ON 350         // Tiempo de LED encendido\n#define LED_OFF 250        // Tiempo entre LEDs\n#define PAUSA 800          // Pausa entre rondas\n#define TIEMPO 5000        // Tiempo base (5 seg)\n\n// D\u00edgitos hex del display\nconst uint8_t display[16][7] = {\n    {1,1,1,1,1,1,0},{0,1,1,0,0,0,0},{1,1,0,1,1,0,1},{1,1,1,1,0,0,1},\n    {0,1,1,0,0,1,1},{1,0,1,1,0,1,1},{1,0,1,1,1,1,1},{1,1,1,0,0,0,0},\n    {1,1,1,1,1,1,1},{1,1,1,1,0,1,1},{1,1,1,0,1,1,1},{0,0,1,1,1,1,1},\n    {1,0,0,1,1,1,0},{0,1,1,1,1,0,1},{1,0,0,1,1,1,1},{1,0,0,0,1,1,1}\n};\n\nconst uint8_t pin_display[7] = { SEG_A, SEG_B, SEG_C, SEG_D, SEG_E, SEG_F, SEG_G };\nconst uint8_t led[4] = { LED_0, LED_1, LED_2, LED_3 };\nconst uint8_t btn[4] = { B_0, B_1, B_2, B_3 };\n\n// Flancos (1 = no presionado)\nint estado_anterior[4] = {1,1,1,1};\n\n// Mostrar en el display\nstatic void digito_display(uint8_t value) {\n    value &amp;= 0x0F; // 0-15\n    for (int i = 0; i &lt; 7; i++)\n        gpio_put(pin_display[i], display[value][i] ? 0 : 1); // 0 \n}\n\n// Apagar display\nstatic void display_off(void) {\n    for (int i = 0; i &lt; 7; i++) gpio_put(pin_display[i], 1);\n}\n\n// Apaga LEDs\nstatic inline void leds_off(void){\n    sio_hw-&gt;gpio_clr = (1u&lt;&lt;LED_0)|(1u&lt;&lt;LED_1)|(1u&lt;&lt;LED_2)|(1u&lt;&lt;LED_3);\n}\n\nstatic inline void led_o(int in, bool on){\n    if (on) sio_hw-&gt;gpio_set = (1u&lt;&lt;led[in]);\n    else    sio_hw-&gt;gpio_clr = (1u&lt;&lt;led[in]);\n}\n\nstatic void parpadeo(int in, int on){\n    leds_off();\n    led_o(in, true);\n    sleep_ms(on);\n    leds_off();\n}\n\nint boton_flanco(void) {\n    for (int i = 0; i &lt; 4; i++) {\n        int lectura = gpio_get(btn[i]); \n\n        if (lectura == 0 &amp;&amp; estado_anterior[i] == 1) {\n            sleep_ms(40);\n            if (gpio_get(btn[i]) == 0) {\n                estado_anterior[i] = 0;\n                return i;\n            } else {\n                estado_anterior[i] = 1;\n            }\n        } else {\n            estado_anterior[i] = lectura;\n        }\n    }\n    return -1;\n}\n\nint esperar_boton(int tiempo){\n    absolute_time_t inicio = get_absolute_time();\n\n    while(1){\n\n        int64_t   = absolute_time_diff_us(inicio, get_absolute_time());\n        if(tiempo_us &gt;= (int64_t)tiempo*1000) return -1; // Timeout\n\n        int b = boton_flanco();\n        if (b != -1) {\n            return b;\n        }\n\n        sleep_ms(1);\n    }\n}\n\n// Genera semilla usando tiempo y bot\u00f3n presionado\nuint32_t semilla(int btn_i){\n    uint32_t t = (uint32_t)(time_us_64() &amp; 0xFFFFFFFF);\n    uint32_t seed = t ^ (0x9E3779B1u * (uint32_t)(btn_i + 1));\n    if (seed == 0) seed = 0xA5A5A5A5u;\n    return seed;\n}\n\nint main(void){\n    stdio_init_all();\n\n    // Inicializar display\n    for (int i = 0; i &lt; 7; i++){\n        gpio_init(pin_display[i]);\n        gpio_set_dir(pin_display[i], GPIO_OUT);\n        gpio_put(pin_display[i], 1); // apagar\n    }\n\n    // Inicializar LEDs\n    for(int i=0;i&lt;4;i++){\n        gpio_init(led[i]);\n        gpio_set_dir(led[i], GPIO_OUT);\n        gpio_put(led[i],0);\n    }\n    leds_off();\n\n    // Inicializar botones\n    for(int i=0;i&lt;4;i++){\n        gpio_init(btn[i]);\n        gpio_set_dir(btn[i], GPIO_IN);\n        gpio_pull_up(btn[i]);\n    }\n\n    for (int i = 0; i &lt; 4; i++) estado_anterior[i] = gpio_get(btn[i]);\n\n    uint8_t secuencia[RONDAS];\n\n    while(true){\n        digito_display(0); // Mostrar 0 esperando inicio\n        int iniciar = esperar_boton(TIEMPO);\n        if(iniciar == -1) continue;\n        srand(semilla(iniciar)); // Semilla aleatoria\n\n        bool game_over = false;\n        int valor = 0;\n\n        for(int ronda=1; ronda&lt;=RONDAS &amp;&amp; !game_over; ronda++){\n            valor = ronda - 1;\n            digito_display(valor); // Mostrar ronda actual\n\n            for(int i=0;i&lt;ronda;i++)\n                secuencia[i] = rand()%4;\n\n            for(int i=0;i&lt;ronda;i++){\n                parpadeo(secuencia[i], LED_ON);\n                sleep_ms(LED_OFF);\n            }\n\n            int ronda_timeout = TIEMPO + (ronda - 1) * 1000;\n\n            int idx = 0;\n            while(idx &lt; ronda){\n                int b = esperar_boton(ronda_timeout);\n                if(b == -1 || b != (int)secuencia[idx]){ // Timeout o error\n                    game_over = true;\n                    break;\n                } else {\n                    parpadeo(b, 80); \n                    idx++;\n                }\n            }\n\n            if(!game_over) sleep_ms(PAUSA);\n        }\n\n        // Game over\n        while(true){\n            digito_display(valor);\n            sleep_ms(400);\n            display_off();\n            sleep_ms(200);\n\n            for(int i=0;i&lt;4;i++){\n                if(gpio_get(btn[i]) == 0){\n                    leds_off();\n                    goto Reiniciar;\n                }\n            }\n        }\nReiniciar:\n        continue;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"SE/Tarea7/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"SE/Tarea7/#video","title":"Video","text":""},{"location":"SE/Tarea8/","title":"Control de Frecuencia \u2014 Canci\u00f3n con Buzzer","text":""},{"location":"SE/Tarea8/#codigo","title":"Codigo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define BUZ_PIN 0\n#define SOL 800.0f\n#define SI  1000.0f\n#define DO  588.0f\n#define FA  700.0f\n#define FAS 740.0f\n#define MI  660.0f\n#define LA  880.0f\n#define TOP 1023\n\n#define time_1 200\n#define time_2 400\n#define time_3 600\n\n#define time_e 200\n#define time_p 300\n\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(BUZ_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(BUZ_PIN);\n    uint chan  = pwm_gpio_to_channel(BUZ_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_enabled(slice, true);\n\n    float f_clk = 150000000.0f; // 150 MHz\n\n    while (true) {\n\n    //Primera\n    float div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_3);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_3);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Segunda\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Tercera\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FAS * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Cuarta\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FAS * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (DO * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (DO * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_3);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Quinta\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_3);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Sexta\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (MI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    //Septima\n    div = f_clk / (SOL * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (MI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_2);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (DO * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (SI * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (LA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_e);\n\n    div = f_clk / (FA * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_chan_level(slice, chan, 500);\n    sleep_ms(time_1);\n\n    pwm_set_chan_level(slice, chan, 0);\n    sleep_ms(time_p);\n\n    }\n}\n</code></pre>"},{"location":"SE/Tarea8/#notas-y-frecuencias-definidas","title":"Notas y Frecuencias Definidas","text":"Nota Frecuencia (Hz) DO 560.0 Hz RE (no definida) MI 660.0 Hz FA 700.0 Hz FA# 740.0 Hz SOL 800.0 Hz LA 880.0 Hz SI 1000.0 Hz"},{"location":"SE/Tarea8/#tiempos-de-duracion-definidos","title":"Tiempos de duraci\u00f3n definidos","text":"Identificador Duraci\u00f3n (ms) <code>time_1</code> 200 ms <code>time_2</code> 400 ms <code>time_3</code> 600 ms <code>time_e</code> (pausa) 200 ms <code>time_p</code> (pausa m\u00e1s larga) 300 ms"},{"location":"SE/Tarea8/#secuencia-musical","title":"Secuencia musical","text":"Estrofa Secuencia de Notas 1 Si - Si 2 La - Sol - La - Si - Sol 3 La - Sol - Fa# - Si - Sol 4 La - Sol - Fa# - Si - Do - Do - Si - Sol - Fa 5 La - Sol - Fa - Sol - La - Fa 6 Sol - Fa - Mi - La - Fa 7 Sol - Fa - Mi - La - Fa - Do - Si - La - Fa"},{"location":"SE/Tarea8/#video","title":"Video","text":""},{"location":"SE/Tarea9/","title":"Bot\u00f3n con instrucci\u00f3n \"LED ON - LED OFF\"","text":"<p>Este c\u00f3digo permite encender y apagar un LED mediante un bot\u00f3n f\u00edsico. Cada vez que se presiona el bot\u00f3n, el LED cambia de estado: si est\u00e1 apagado se enciende (\u201cLED ON\u201d) y si est\u00e1 encendido se apaga (\u201cLED OFF\u201d).</p> <p>C\u00f3digo Env\u00edo</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nstring mensaje = \"\";\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    printf(\"Esperando mensajes...\\n\");\n\n    while (true) {\n        if (uart_is_readable(UART_ID)) {\n            char ch = uart_getc(UART_ID);\n            printf(\"%c\", ch);\n            mensaje += ch;\n\n            if (ch == ';') {\n                string comando = mensaje.substr(0, mensaje.length() - 1);\n\n                if (comando == \"on\") {\n                    gpio_put(LED_PIN, 1);\n                    printf(\"\\nLED ENCENDIDO\\n\");\n                } else if (comando == \"off\") {\n                    gpio_put(LED_PIN, 0);\n                    printf(\"\\nLED APAGADO\\n\");\n                } else {\n                    printf(\"\\nMensaje no reconocido: '%s'\\n\", comando.c_str());\n                }\n\n                mensaje = \"\";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre> <p>C\u00f3digo Recepci\u00f3n</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nstring mensaje = \"\";\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    printf(\"Esperando mensajes...\\n\");\n\n    while (true) {\n        if (uart_is_readable(UART_ID)) {\n            char ch = uart_getc(UART_ID);\n            printf(\"%c\", ch);\n            mensaje += ch;\n\n            if (ch == ';') {\n                string comando = mensaje.substr(0, mensaje.length() - 1);\n\n                if (comando == \"on\") {\n                    gpio_put(LED_PIN, 1);\n                    printf(\"\\nLED ENCENDIDO\\n\");\n                } else if (comando == \"off\") {\n                    gpio_put(LED_PIN, 0);\n                    printf(\"\\nLED APAGADO\\n\");\n                } else {\n                    printf(\"\\nMensaje no reconocido: '%s'\\n\", comando.c_str());\n                }\n\n                mensaje = \"\";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"SE/Tarea9/#video","title":"Video","text":""}]}